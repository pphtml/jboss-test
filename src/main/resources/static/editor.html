<!doctype html>

<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Regular Expression</title>
    <link rel="stylesheet" href="/static/css/bootstrap.min.css">
    <link rel="stylesheet" href="/static/css/styles.css">
</head>
<body>

<div id="app">
    <div class="container">
        <div class="bs-example" data-example-id="text-form-control">
            <form><input class="form-control" placeholder="Text input" :value="expression" @keyup.stop="updateExpression($event.target.value)"></form>

        </div>
        <figure class="highlight">
            <pre><code class="language-html" data-lang="html"><span class="nt">{{expression}}</span></code></pre>
        </figure>
        <!--<textarea style="padding: 0px; width: 100%; height: 15em; outline: medium none;" autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" wrap="off">-->

        <!--</textarea>-->
    </div>

    <div class="mycontainer">
        <div class="backdrop">
            <div class="highlights"></div>
        </div>
        <textarea autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
This demo shows how to highlight bits of text within a textarea. Alright, that's a lie. You can't actually render markup inside a textarea. However, you can fake it by carefully positioning a div behind the textarea and adding your highlight markup there. JavaScript takes care of syncing the content and scroll position from the textarea to the div, so everything lines up nicely. Hit the toggle button to peek behind the curtain. And feel free to edit this text. All capitalized words will be highlighted.
        </textarea>
    </div>


    <!--<div class="container">-->
        <!--&lt;!&ndash;<router-view></router-view>&ndash;&gt;-->
        <!--<p>{{ count }}</p>-->
        <!--<p>-->
            <!--<button @click="increment">+</button>-->
            <!--<button @click="decrement">-</button>-->
        <!--</p>-->
    <!--</div><br><br>-->
    <!--<footer class="container-fluid text-center"></footer>-->

    <div>
        <p>
            Lastname: {{ user.lastname }}<br />
            Firstname: {{ user.firstname }}
        </p>
        <p>
            User object: {{ user }}
        </p>
        <!--<input v-model="user.lastname" />-->
        <!--<input v-model="user.firstname" />-->

        <input :value="user.lastname" @keyup.stop="updateLastname($event.target.value)" />
        <input :value="user.firstname" @keyup.stop="updateFirstname($event.target.value)"/>

    </div>
</div>


<script src="/static/js/jquery.min.js"></script>
<script src="/static/js/bootstrap.min.js"></script>
<script src="/static/js/vue.js"></script>
<script src="/static/js/vuex.js"></script>
<script src="/static/js/vue-router.js"></script>
<script src="/static/js/axios.js"></script>
<script src="/static/js/lodash.js"></script>
<script>
//    new Vue({
//        el: '#app',
//        data: {
//            input: '# hello'
//        },
//        computed: {
//            compiledMarkdown: function () {
//                return marked(this.input, { sanitize: true })
//            }
//        },
//        methods: {
//            update: _.debounce(function (e) {
//                this.input = e.target.value
//            }, 300)
//        }
//    })

const store = new Vuex.Store({
//    strict: true,
    state: {
        count: 0,
        expression: '',
        user: {
            lastname: '',
            firstname: ''
        }
    },
    mutations: {
        increment: state => state.count++,
        decrement: state => state.count--,
        updateUser: function (state, user) {
            Object.assign(state.user, user);
        },
        updateExpression: (state, expression) => state.expression = expression
    }
});

new Vue({
    el: '#app',
    store: store,
    computed: {
        // mapGetters(),
        count () {
            return store.state.count
        },
        expression() {
            return this.$store.state.expression;
        },
        user() {
            return this.$store.state.user;
        }
    },
//    data () {
//        return {
//            user: this.$store.state.user
//        };
//    },
    methods: {
        increment () {
            console.info('tady');
            store.commit('increment')
        },
        decrement () {
            store.commit('decrement')
        },
        updateExpression(expression) {
            this.$store.commit('updateExpression', expression);
        },
        updateFirstname(firstname) {
            this.$store.commit('updateUser', {firstname});
        },
        updateLastname(lastname) {
            this.$store.commit('updateUser', {lastname});
        }
    }
});










var $container = $('.container');
var $backdrop = $('.backdrop');
var $highlights = $('.highlights');
var $textarea = $('textarea');

// yeah, browser sniffing sucks, but there are browser-specific quirks to handle that are not a matter of feature detection
var ua = window.navigator.userAgent.toLowerCase();
var isIE = !!ua.match(/msie|trident\/7|edge/);
var isWinPhone = ua.indexOf('windows phone') !== -1;
var isIOS = !isWinPhone && !!ua.match(/ipad|iphone|ipod/);

function applyHighlights(text) {
    text = text
        .replace(/\n$/g, '\n\n')
        .replace(/[A-Z].*?\b/g, '<mark>$&</mark>');

    if (isIE) {
        // IE wraps whitespace differently in a div vs textarea, this fixes it
        text = text.replace(/ /g, ' <wbr>');
    }

    return text;
}

function handleInput() {
    var text = $textarea.val();
    var highlightedText = applyHighlights(text);
    $highlights.html(highlightedText);
}

function handleScroll() {
    var scrollTop = $textarea.scrollTop();
    $backdrop.scrollTop(scrollTop);

    var scrollLeft = $textarea.scrollLeft();
    $backdrop.scrollLeft(scrollLeft);
}

function bindEvents() {
    $textarea.on({
        'input': handleInput,
        'scroll': handleScroll
    });
}

bindEvents();
handleInput();

</script>
</body>
</html>

<!--https://ypereirareis.github.io/blog/2017/04/25/vuejs-two-way-data-binding-state-management-vuex-strict-mode/-->